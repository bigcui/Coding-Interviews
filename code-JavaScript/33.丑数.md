# 33.丑数
[《剑指Offer》刷题GitHub链接](https://github.com/zhning12/Coding-Interviews)

[题目链接](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

## 解题思路

此处引用**事无巨细，悉究本末**大佬的题解（因为真的写的非常清楚精辟了）：

通俗易懂的解释：

首先从丑数的定义我们知道，一个丑数的因子只有`2,3,5`，那么丑数`p = 2 ^ x * 3 ^ y * 5 ^ z`，换句话说一个丑数一定由另一个丑数乘以`2`或者乘以`3`或者乘以`5`得到，那么我们从1开始乘以`2,3,5`，就得到`2,3,5`三个丑数，在从这三个丑数出发乘以`2,3,5`就得到`4，6,10,6，9,15,10,15,25`九个丑数，我们发现这种方法会得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：

1. 丑数数组： 1
乘以2的队列：2
乘以3的队列：3
乘以5的队列：5
选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
2. 丑数数组：1,2
乘以2的队列：4
乘以3的队列：3，6
乘以5的队列：5，10
选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
3. 丑数数组：1,2,3
乘以2的队列：4,6
乘以3的队列：6,9
乘以5的队列：5,10,15
选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
4. 丑数数组：1,2,3,4
乘以2的队列：6，8
乘以3的队列：6,9,12
乘以5的队列：5,10,15,20
选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
5. 丑数数组：1,2,3,4,5
乘以2的队列：6,8,10，
乘以3的队列：6,9,12,15
乘以5的队列：10,15,20,25
选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；
……………………

### **疑问：**

1. 为什么分三个队列？

丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以`2,3,5`选出的最小数，一定比以前未乘以`2,3,5`大，同时对于三个队列内部，按先后顺序乘以`2,3,5`分别放入，所以**同一个队列内部也是有序的**；

2. 为什么比较三个队列头部最小的数放入丑数数组？
因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。

### **方法总结：**
- 维护三个数组：`l2, l3, l5`
- 将当前list中的最后一位分别乘以`2, 3, 5`放入三个数组中
- 比较三个数组的第一个元素，取得三个list的最小值放入丑数数列
- 从三个数组中删除刚才放入的那个值，考虑到可能出现重复的情况，所以需要三个`if`作判断
- 注意：当`index == 0`时返回值为0

## Code


```javascript
function GetUglyNumber_Solution(index)
{
    // write code here
    var l2 = [];
    var l3 = [];
    var l5 = [];
    var list = [0, 1];
    var i = 1;
    while(i <= index){
        l2.push(list[i] * 2);
        l3.push(list[i] * 3);
        l5.push(list[i] * 5);
        var min = Math.min(l2[0], l3[0], l5[0]);
        list.push(min);
        if(min === l2[0]){
            l2.shift();
        }
        if(min === l3[0]){
            l3.shift();
        }
        if(min === l5[0]){
            l5.shift();
        }
        i++;
    }
    return list[index];
}
    
```